diff -ruNP minix/conway_install/conway.c SNPM2/conway_install/conway.c
--- minix/conway_install/conway.c	1969-12-31 21:00:00.000000000 -0300
+++ SNPM2/conway_install/conway.c	2016-05-26 22:13:40.262166730 -0300
@@ -0,0 +1,527 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <minix/mthread.h>
+#include <termios.h>
+#include <sys/time.h>
+#include <sys/types.h>
+
+
+#define green "\033[9;32m"        /* 4 -> underline ;  32 -> green */
+#define red "\033[9;1m" 
+#define none   "\033[0m"        /* to flush the previous property */
+
+
+
+
+int dst = 0;
+int rondas = 0;
+/* Estructura para el manejo del programa*/
+typedef struct MyData {
+
+    int M, m;
+    int N, n;
+    int t_ini;
+    int z, h;
+    int **tablero;
+    int **tablero_anterior;
+    int **ini;
+    mthread_barrier_t barrera;
+    mthread_mutex_t  ghMutex2;
+
+} MYDATA, *PMYDATA;
+
+/* Estructura para el manejo de los hilos*/
+typedef struct DataHilos {
+    int **Regiones; //Matriz con las cordenadas de cada secion por hilo
+    int cch;        //Cantidad de secciones por hilo
+    int e;       
+    MYDATA *data;
+} DataHilos, *PDataHilos;
+/*Funcion que lee el archivo config,
+guarda los primeros 5 datos en arr[] (M,N,m,n,h) y
+llena el vector ini[][] con los vivos iniciales y lo retorna. */ 
+
+void Imprimir_tablero(PMYDATA s, int o);
+int **obtener_valores(int *arr, int *t_ini, char *argv);
+void ayuda(void);
+int **dividir_tablero(int M, int N, int m, int n, int *t_div);
+void iniciar_tablero(PMYDATA Datos);
+int Estavivo(PMYDATA s, int x, int y);
+void func_salir(PMYDATA s);
+void Imprimir_tablero(PMYDATA s, int o);
+int work2(int x1, int y1, int x2, int y2, PMYDATA Datos);
+void work(PDataHilos DH);
+void work3(PDataHilos Data);
+
+
+int **obtener_valores(int *arr, int *t_ini, char *argv){
+
+    FILE *fp;
+    int M = 5;
+    int N = 15;
+    int i =0;
+    int j =0;
+    int co = 0;
+    char ch, cha;
+
+    char **c = (char **)malloc (M*sizeof(char *));
+    for (i = 0; i < M; i++) c[i] = (char *) calloc (N,sizeof(char));
+
+    fp = fopen ( argv, "r" );
+    if (fp==NULL){
+        fputs ("ERROR: No se escuentra archivo ",stderr); 
+        printf("%s. Intente conway -h para obtener ayuda. \n", argv);
+        exit (1);
+    }
+
+    while(feof(fp)==0){
+        cha = ch;
+        ch = fgetc(fp);
+        if(cha == '\n' && ch != EOF)co++;
+    }
+    co = co - 2;
+    *t_ini = co;
+
+    int **ini = (int **)malloc(co*sizeof(int *));
+    for (i = 0; i < co; i++) ini[i] = (int *) calloc (2, sizeof(int));
+
+    rewind(fp);
+
+    for(i = 0; i < M; i++){
+             fscanf(fp, "%s" ,c[i]);
+             if((*c[i]!=' ') && (*c[i]!='1') && (*c[i]!='2') && (*c[i]!='3') && (*c[i]!='4') && (*c[i]!='5') && (*c[i]!='6') && (*c[i]!='7') && (*c[i]!='8') && (*c[i]!='9') && (*c[i]!='0')){
+                printf("Input incorrecto, para obtener ayuda use el comando 'conway -h' \n");
+                exit(1);
+             }
+    }
+        for(j =0; j < M; j++){
+            arr[j] = atoi(c[j]);
+        }
+    char buffer[10];
+    for(i = 0; i < co; i++){
+
+          fscanf(fp, "%s" ,buffer);
+          ini[i][0] = atoi(buffer);
+          fscanf(fp, "%s" ,buffer);
+          ini[i][1] = atoi(buffer);
+    }
+    //free(c);
+    //free(buffer);
+    return ini;
+}
+
+void ayuda(){
+    system("clear");
+    printf("---------------\n");
+    printf("AYUDA DE CONWAY\n");
+    printf("---------------\n\n");
+    printf("Para iniciar conway escriba 'conway config', donde 'config' es un archivo con una configuracion inicial valida. \n" );
+    printf("El archivo 'config' debe estar dentro del directorio en el que se encuentra conway.\n\n");
+    printf("Procure que el archivo 'config' tenga la siguiente estructura:\n");
+    printf("---------------------------------------------------------------------------\n\n" );
+    printf("M    N    // Donde M y N son las dimensiones del tablero. \n");
+    printf("m    n    // Donde m y n son las dimensiones de las regiones.\n" );
+    printf("h         // Donde h es la cantidad de hilos de trabajo.\n" );
+    printf("x1   y1   // Donde (x, y) representa las cordenadas de un vivo inicial.\n" );
+    printf(".    .    \n" );
+    printf(".    .    \n" );
+    printf(".    .    \n\n" );
+    printf("xn   yn   \n" );
+    printf("---------------------------------------------------------------------------\n\n" );
+    printf("**Las posiciones iniciales deben caer dentro del tablero** (xi,yi) < (M,N).\n");
+    printf("**Todos los valores deben ser positivos o iguales a cero** \n");
+    printf("(M, N, m, n, h, (x1,y1),...,(xn,yn)) >= 0\n");
+}
+
+int **dividir_tablero(int M, int N, int m, int n, int *t_div){
+
+    int cM = M/m;
+    int cN = N/n;
+
+    int i,c,c2;
+    c=0;
+    c2 = 0;
+
+    if(M%m != 0)cM++;
+    if(N%n != 0)cN++;
+
+    int t = cM*cN;
+    *t_div = t;
+
+    int **vector = (int **)malloc (t*sizeof(int *));
+    for (i = 0; i < t; i++) vector[i] = (int *) calloc(4, sizeof(int));
+
+    for(i = 0; i < t; i++){
+
+        if((c2 + 1)*m > M){
+            vector[i][3]=c2*m + M%m;
+        }else{
+            vector[i][3] = (c2 + 1)*m;
+        }
+        if(c + n > N){
+            vector[i][2] = c + N%n;
+        }else{
+            vector[i][2] = c + n;
+        }
+        vector[i][0] = c;
+        vector[i][1] = c2*m;
+
+        c2++;
+
+        if(c2 == cM){
+            c2 = 0;
+            c += n;
+        }
+    }
+
+return vector;
+}
+
+void iniciar_tablero(PMYDATA Datos){ //inicia el tablero con los vivos iniciales
+
+    int l = Datos->t_ini;
+    int **vivos = Datos->ini;
+    int **tablero_anterior = Datos->tablero_anterior;
+    int i;
+
+    for (i = 0; i < l; i++)
+    {
+        if(vivos[i][0] >= Datos->M || vivos[i][1] >= Datos->N){
+            printf("Input incorrecto, para obtener ayuda use el comando 'conway -h' \n");
+            exit(1);
+        }
+        tablero_anterior[vivos[i][0]][vivos[i][1]] = 1;
+    }
+
+}
+
+
+int Estavivo(PMYDATA s, int x, int y){
+
+    
+    int M = s->M;
+    int N = s->N;
+    int cont = 0;
+    //printf("%i %i \n", x,y);
+   
+    if( x-1 >= 0 && y-1 >= 0){
+        if(s->tablero_anterior[x-1][y-1] == 1)cont++;
+    }
+    if( x-1 >= 0 && y+1 < N){
+        if(s->tablero_anterior[x-1][y+1] == 1)cont++;
+    }
+    if(x+1 < M && y+1 < N){
+        if(s->tablero_anterior[x+1][y+1] == 1)cont++;
+    }
+    if( x+1 < M && y-1 >= 0){
+        if(s->tablero_anterior[x+1][y-1] == 1)cont++;
+    }
+    if(x+1 < M){
+        if(s->tablero_anterior[x+1][y] == 1)cont++;
+    }
+    if(x-1 >= 0){
+        if(s->tablero_anterior[x-1][y] == 1 )cont++;
+    }
+    if(y-1 >= 0){
+        if(s->tablero_anterior[x][y-1] == 1 )cont++;
+    }
+    if(y+1 < N){
+        if(s->tablero_anterior[x][y+1] == 1)cont++;
+    }
+
+
+    if (s->tablero_anterior[x][y] == 1 && ( cont == 2 || cont == 3))
+    {   
+        s->tablero[x][y] = 1;                  
+        return 0;
+    }
+    if (s->tablero_anterior[x][y] == 0 && cont == 3)
+    {
+        s->tablero[x][y] = 1;
+       
+        return 0;
+    }
+    if (cont < 2 || cont > 3)
+    {
+        s->tablero[x][y] = 0;
+        
+        return 0;
+    }
+   
+    return 0;
+}
+
+
+
+void func_salir(PMYDATA s){
+
+    static struct termios oldt, newt;
+    tcgetattr( STDIN_FILENO, &oldt);
+    newt = oldt;
+    newt.c_lflag &= ~(ICANON);          
+    tcsetattr( STDIN_FILENO, TCSANOW, &newt);
+
+    int tiempo_de_espera = 1; //en segundos
+    char aux[1]; 
+    int aux2;
+    fd_set input;
+    struct timeval timeout;
+    int leer = 0;
+    int read_aux = 0;
+
+    FD_ZERO(&input );
+    
+    FD_SET(0, &input);
+
+    timeout.tv_sec = tiempo_de_espera;   
+    timeout.tv_usec = 0;   
+
+    leer = select(1, &input, NULL, NULL, &timeout);
+
+    if(leer == -1){
+
+        tcsetattr( STDIN_FILENO, TCSANOW, &oldt);
+    }
+    if(leer) {
+        read_aux = read(0, aux, 19);
+        aux2 = aux[read_aux - 1];
+        if(aux2 >= -1){
+            
+            tcsetattr( STDIN_FILENO, TCSANOW, &oldt);
+            free(s->tablero);
+            free(s->tablero_anterior);
+            free(s->ini);
+
+            mthread_barrier_destroy(&(s->barrera));
+            mthread_mutex_destroy(&(s->ghMutex2));
+            printf("\n");
+
+            exit(1);
+
+    }
+
+    tcsetattr( STDIN_FILENO, TCSANOW, &oldt);
+    return;
+    }
+}
+
+
+void Imprimir_tablero(PMYDATA s, int o){
+
+    mthread_mutex_lock(&(s->ghMutex2)); 
+    s->z++;
+    mthread_mutex_unlock(&(s->ghMutex2)); 
+
+    if(s->z == s->h || o == 1){
+    int i,j,c; 
+
+    c = 0;                        
+    system("clear"); 
+
+    printf("%s %i hilos en regiones de %ix%i.%s \n", green, s->h, s->m, s->n, green);
+
+    for(i = 0; i < s->N; i++)printf("----");
+
+    printf("\n");
+
+    for(i = 0; i < s->M; i++){
+        for(j = 0; j < s->N; j++){
+
+
+            if(o == 0)s->tablero_anterior[i][j] = s->tablero[i][j];
+
+            if(s->tablero_anterior[i][j] == 1){
+
+                
+                printf("   %s#%s", green, none);
+                c++;
+                
+                continue;
+            }
+
+            printf("   %s.%s", red, red);
+        }printf("\n \n");
+    }
+    for(i = 0; i < s->N; i++)printf("----");
+
+    printf("\n");
+    rondas = rondas + 1;
+    printf("%sVivos: %i. Ronda: %i.%s\n", green, c, rondas, none); 
+    s->z = 0;
+ }
+}
+
+int work2(int x1, int y1, int x2, int y2, PMYDATA Datos){
+    int i,j;
+    for(i = 0; i + x1 < x2; i++){
+        for(j = 0; j + y1 < y2; j++){
+            Estavivo(Datos, i + x1, j + y1);
+        }
+    }
+    return 0;
+}
+
+void work(PDataHilos DH){
+
+    int i;
+   
+        for(i = 0; i < DH->cch; i++){
+            work2(DH->Regiones[i][0],DH->Regiones[i][1],DH->Regiones[i][2],DH->Regiones[i][3], DH->data);
+       
+        }
+}
+
+int a = 0;
+
+void work3(PDataHilos Data){
+    
+            work(Data);
+
+            mthread_barrier_sync(&(Data->data->barrera));
+            Imprimir_tablero(Data->data, 0);//aca se copia la matriz a matriz anterior
+            mthread_barrier_sync(&(Data->data->barrera));
+}
+
+int main(argc, argv)
+int argc;
+char *argv[];
+{   
+    if(argc == 1){
+        printf("Falta archivo config. Para obtener ayuda ejecute 'conway -h'\n");
+        return 0;
+    }
+
+    if(argv[1][0] == '-' && argv[1][1] == 'h'){
+        ayuda();
+        return 0;
+    }
+    
+
+    PMYDATA Datos = (PMYDATA) malloc(sizeof(MYDATA));
+
+    int **matriz;
+    int **ini;
+    int **div;
+    int *arr;
+    int t_ini;
+    int t_div;
+
+    int **matriz_anterior; //inicializacion del tablero anterior
+
+    int M,N,n,m,h; //Variables de inicio
+
+    int i, j, k; //variables auxiliares
+
+    arr = (int *)calloc(5, sizeof(int));
+
+
+    ini = obtener_valores(arr, &t_ini, argv[1]); //obtiene los datos del archivo
+
+    /* Escribe los valores obtenidos del archivo confi*/
+    M = arr[0];
+    N = arr[1];
+    m = arr[2];
+    n = arr[3];
+    h = arr[4];
+
+    if(n > N || m > M || h > M*N){
+         printf("Input incorrecto, para obtener ayuda use el comando 'conway -h' \n");
+         exit(1);
+    }
+
+    /*Inicia las matrices del tablero y las posiciones iniciales en 0*/
+    matriz = (int **)malloc (M*sizeof(int *));
+    for (i = 0; i < M; i++) matriz[i] = (int *) calloc(N, sizeof(int));
+    /*Inicia la matriz anterior, futura variable de  tablero_anterior de MYData*/
+    matriz_anterior = (int **)malloc (M*sizeof(int *));
+    for (i = 0; i < M; i++) matriz_anterior[i] = (int *) calloc(N, sizeof(int));
+
+
+    /*Pasa los datos a la estructura MYDATA */
+    Datos->M = M;
+    Datos->N = N;
+    Datos->m = m;
+    Datos->n = n;
+    Datos->z = 0;
+    Datos->h = h;
+    Datos->tablero = matriz;
+    Datos->tablero_anterior = matriz_anterior; //copia matriz 1
+    Datos->ini = ini;
+    Datos->t_ini = t_ini;
+
+    mthread_mutex_init(&(Datos->ghMutex2), NULL);
+    mthread_barrier_init(&(Datos->barrera), h);
+
+    /*Inicia el tablero con los vivos iniciales*/
+
+    iniciar_tablero(Datos);
+
+    /*Divide el tablero en los tama√±os maximos asignados por m y n */
+    div = dividir_tablero(M, N, m, n, &t_div);
+    
+    /*Inicio codigo de los hilos*/
+
+    /*PONER LOS HILOS DE MINIX */
+    PDataHilos Data[h];
+    mthread_thread_t hilos[h];
+
+    int cch = t_div/h;
+    int h_aux = h;
+
+    for(i = 0; i < h; i++){
+        Data[i] = (PDataHilos) malloc(sizeof(DataHilos));
+    }
+
+    if(t_div%h != 0){
+        h--;
+        h_aux--;
+        Data[h]->Regiones = (int **)malloc ((cch + t_div%(h + 1))*sizeof(int *));
+        for (j = 0; j < (cch + t_div%(h + 1)); j++) Data[h]->Regiones[j] = (int *) calloc(4, sizeof(int));
+
+        Data[h]->cch = cch + t_div%(h + 1);
+        Data[h]->data = Datos;
+        Data[h]->e = 1;
+
+        for(k = 0; k < (cch + t_div%(h + 1)); k++){
+            Data[h]->Regiones[k][0] = div[k + h_aux*cch][0];
+            Data[h]->Regiones[k][1] = div[k + h_aux*cch][1];
+            Data[h]->Regiones[k][2] = div[k + h_aux*cch][2];
+            Data[h]->Regiones[k][3] = div[k + h_aux*cch][3];
+        }
+        h++;
+    }
+
+    for(i = 0; i < h_aux; i++){
+        Data[i]->Regiones = (int **)malloc (cch*sizeof(int *));
+        for (j = 0; j < cch; j++) Data[i]->Regiones[j] = (int *) calloc(4, sizeof(int));
+        Data[i]->cch = cch;
+        Data[i]->data = Datos;
+        Data[i]->e = 1;
+
+        for(k = 0; k < cch; k++){
+            Data[i]->Regiones[k][0] = div[k + i*cch][0];
+            Data[i]->Regiones[k][1] = div[k + i*cch][1];
+            Data[i]->Regiones[k][2] = div[k + i*cch][2];
+            Data[i]->Regiones[k][3] = div[k + i*cch][3];
+        }
+    }
+
+    Imprimir_tablero(Datos, 1);
+    
+    while(1 == 1){
+
+        for(i = 0; i < h; i++){
+            mthread_create(&hilos[i], NULL, (void*)work3, Data[i]);
+        }  
+
+        for(i = 0; i < h; i++){
+            mthread_join(hilos[i], NULL);
+        }
+       func_salir(Datos);
+    }
+    free(arr);
+    free(div);
+    /*Fin codigo de los hilos*/
+
+}
diff -ruNP minix/conway_install/Makefile SNPM2/conway_install/Makefile
--- minix/conway_install/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ SNPM2/conway_install/Makefile	2016-05-26 22:13:40.262166730 -0300
@@ -0,0 +1,19 @@
+CODE= conway.c
+OBJ= conway
+LIB= -lmthread
+FLAGS= -o
+CC= clang
+DIR= /usr/games
+USR= /home/conway
+
+install: 
+
+	$(CC) $(CODE) $(LIB) $(FLAGS) $(OBJ)
+
+	cp $(OBJ) $(DIR)
+
+	ln -s $(DIR)/$(OBJ) $(USR)
+
+	rm $(OBJ)
+
+
diff -ruNP minix/conway_install/README.txt SNPM2/conway_install/README.txt
--- minix/conway_install/README.txt	1969-12-31 21:00:00.000000000 -0300
+++ SNPM2/conway_install/README.txt	2016-05-26 23:12:16.191701699 -0300
@@ -0,0 +1,7 @@
+Para instalar conway ejecute "make install" en la carpeta conway_install dentro del src de minix.
+
+Luego, para ejecutar conway ejecuta "conway config"desde cualquier directorio.
+
+config debe ser una configuraciÛn v·lida de conway. Para obtener ayuda ejecute "conway -h".
+
+
diff -ruNP minix/conway_install/README.txt~ SNPM2/conway_install/README.txt~
--- minix/conway_install/README.txt~	1969-12-31 21:00:00.000000000 -0300
+++ SNPM2/conway_install/README.txt~	2016-05-26 22:13:40.262166730 -0300
@@ -0,0 +1,5 @@
+Para instalar conway ejecute "make install" en la carpeta conway_install dentro del src de minix.
+
+Luego, para ejecutar conway ejecuta "conway config"desde cualquier directorio.
+
+config debe ser una configuraciÛn v·lida de conway. Para obtener ayuda ejecute "conway -h".
\ No newline at end of file
diff -ruNP minix/external/bsd/llvm/dist/llvm/projects/LLVMBuild.txt SNPM2/external/bsd/llvm/dist/llvm/projects/LLVMBuild.txt
--- minix/external/bsd/llvm/dist/llvm/projects/LLVMBuild.txt	2016-05-26 22:17:13.115137434 -0300
+++ SNPM2/external/bsd/llvm/dist/llvm/projects/LLVMBuild.txt	1969-12-31 21:00:00.000000000 -0300
@@ -1,21 +0,0 @@
-;===- ./projects/LLVMBuild.txt ---------------------------------*- Conf -*--===;
-;
-;                     The LLVM Compiler Infrastructure
-;
-; This file is distributed under the University of Illinois Open Source
-; License. See LICENSE.TXT for details.
-;
-;===------------------------------------------------------------------------===;
-;
-; This is an LLVMBuild description file for the components in this subdirectory.
-;
-; For more information on the LLVMBuild system, please see:
-;
-;   http://llvm.org/docs/LLVMBuild.html
-;
-;===------------------------------------------------------------------------===;
-
-[component_0]
-type = Group
-name = Projects
-parent = $ROOT
diff -ruNP minix/external/bsd/llvm/dist/llvm/test/Verifier/bitcast-address-space-through-constant-inttoptr-inside-gep-i SNPM2/external/bsd/llvm/dist/llvm/test/Verifier/bitcast-address-space-through-constant-inttoptr-inside-gep-i
--- minix/external/bsd/llvm/dist/llvm/test/Verifier/bitcast-address-space-through-constant-inttoptr-inside-gep-i	1969-12-31 21:00:00.000000000 -0300
+++ SNPM2/external/bsd/llvm/dist/llvm/test/Verifier/bitcast-address-space-through-constant-inttoptr-inside-gep-i	2016-05-26 22:13:44.430620125 -0300
@@ -0,0 +1,10 @@
+; RUN: not llvm-as -verify -disable-output < %s
+target datalayout = "e-p:32:32:32-p1:16:16:16-p2:8:8:8-i1:8:32-i8:8:32-i16:16:32-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:32:64-v128:32:128-a0:0:32-n8:16:32"
+
+; Check that we can find inttoptr -> illegal bitcasts when hidden
+; inside constantexpr pointer operands
+define i32 addrspace(2)* @illegal_bitcast_inttoptr_as_1_to_2_inside_gep() {
+  %cast = getelementptr i32 addrspace(2)* bitcast (i32 addrspace(1)* inttoptr (i32 1234 to i32 addrspace(1)*) to i32 addrspace(2)*), i32 3
+  ret i32 addrspace(2)* %cast
+}
+
diff -ruNP minix/external/bsd/llvm/dist/llvm/test/Verifier/bitcast-address-space-through-constant-inttoptr-inside-gep-instruction.ll SNPM2/external/bsd/llvm/dist/llvm/test/Verifier/bitcast-address-space-through-constant-inttoptr-inside-gep-instruction.ll
--- minix/external/bsd/llvm/dist/llvm/test/Verifier/bitcast-address-space-through-constant-inttoptr-inside-gep-instruction.ll	2016-05-26 22:17:14.059253032 -0300
+++ SNPM2/external/bsd/llvm/dist/llvm/test/Verifier/bitcast-address-space-through-constant-inttoptr-inside-gep-instruction.ll	1969-12-31 21:00:00.000000000 -0300
@@ -1,10 +0,0 @@
-; RUN: not llvm-as -verify -disable-output < %s
-target datalayout = "e-p:32:32:32-p1:16:16:16-p2:8:8:8-i1:8:32-i8:8:32-i16:16:32-i32:32:32-i64:32:64-f32:32:32-f64:32:64-v64:32:64-v128:32:128-a0:0:32-n8:16:32"
-
-; Check that we can find inttoptr -> illegal bitcasts when hidden
-; inside constantexpr pointer operands
-define i32 addrspace(2)* @illegal_bitcast_inttoptr_as_1_to_2_inside_gep() {
-  %cast = getelementptr i32 addrspace(2)* bitcast (i32 addrspace(1)* inttoptr (i32 1234 to i32 addrspace(1)*) to i32 addrspace(2)*), i32 3
-  ret i32 addrspace(2)* %cast
-}
-
diff -ruNP minix/games/conway/config SNPM2/games/conway/config
--- minix/games/conway/config	1969-12-31 21:00:00.000000000 -0300
+++ SNPM2/games/conway/config	2016-05-26 22:13:45.098692992 -0300
@@ -0,0 +1,10 @@
+11 11
+2 2
+2
+4 5 
+5 4 
+6 6 
+5 4
+5 6  
+7 7
+8 8
diff -ruNP minix/games/conway/conway.1 SNPM2/games/conway/conway.1
--- minix/games/conway/conway.1	1969-12-31 21:00:00.000000000 -0300
+++ SNPM2/games/conway/conway.1	2016-05-26 23:40:56.107680985 -0300
@@ -0,0 +1,2 @@
+hola
+
diff -ruNP minix/games/conway/conway.1~ SNPM2/games/conway/conway.1~
--- minix/games/conway/conway.1~	1969-12-31 21:00:00.000000000 -0300
+++ SNPM2/games/conway/conway.1~	2016-05-26 23:40:54.343513701 -0300
@@ -0,0 +1,2 @@
+hola
+
diff -ruNP minix/games/conway/conway.c SNPM2/games/conway/conway.c
--- minix/games/conway/conway.c	1969-12-31 21:00:00.000000000 -0300
+++ SNPM2/games/conway/conway.c	2016-05-26 22:13:45.098692992 -0300
@@ -0,0 +1,527 @@
+#include <stdio.h>
+#include <stdlib.h>
+#include <unistd.h>
+#include <minix/mthread.h>
+#include <termios.h>
+#include <sys/time.h>
+#include <sys/types.h>
+
+
+#define green "\033[9;32m"        /* 4 -> underline ;  32 -> green */
+#define red "\033[9;1m" 
+#define none   "\033[0m"        /* to flush the previous property */
+
+
+
+
+int dst = 0;
+int rondas = 0;
+/* Estructura para el manejo del programa*/
+typedef struct MyData {
+
+    int M, m;
+    int N, n;
+    int t_ini;
+    int z, h;
+    int **tablero;
+    int **tablero_anterior;
+    int **ini;
+    mthread_barrier_t barrera;
+    mthread_mutex_t  ghMutex2;
+
+} MYDATA, *PMYDATA;
+
+/* Estructura para el manejo de los hilos*/
+typedef struct DataHilos {
+    int **Regiones; //Matriz con las cordenadas de cada secion por hilo
+    int cch;        //Cantidad de secciones por hilo
+    int e;       
+    MYDATA *data;
+} DataHilos, *PDataHilos;
+/*Funcion que lee el archivo config,
+guarda los primeros 5 datos en arr[] (M,N,m,n,h) y
+llena el vector ini[][] con los vivos iniciales y lo retorna. */ 
+
+void Imprimir_tablero(PMYDATA s, int o);
+int **obtener_valores(int *arr, int *t_ini, char *argv);
+void ayuda(void);
+int **dividir_tablero(int M, int N, int m, int n, int *t_div);
+void iniciar_tablero(PMYDATA Datos);
+int Estavivo(PMYDATA s, int x, int y);
+void func_salir(PMYDATA s);
+void Imprimir_tablero(PMYDATA s, int o);
+int work2(int x1, int y1, int x2, int y2, PMYDATA Datos);
+void work(PDataHilos DH);
+void work3(PDataHilos Data);
+
+
+int **obtener_valores(int *arr, int *t_ini, char *argv){
+
+    FILE *fp;
+    int M = 5;
+    int N = 15;
+    int i =0;
+    int j =0;
+    int co = 0;
+    char ch, cha;
+
+    char **c = (char **)malloc (M*sizeof(char *));
+    for (i = 0; i < M; i++) c[i] = (char *) calloc (N,sizeof(char));
+
+    fp = fopen ( argv, "r" );
+    if (fp==NULL){
+        fputs ("ERROR: No se escuentra archivo ",stderr); 
+        printf("%s. Intente conway -h para obtener ayuda. \n", argv);
+        exit (1);
+    }
+
+    while(feof(fp)==0){
+        cha = ch;
+        ch = fgetc(fp);
+        if(cha == '\n' && ch != EOF)co++;
+    }
+    co = co - 2;
+    *t_ini = co;
+
+    int **ini = (int **)malloc(co*sizeof(int *));
+    for (i = 0; i < co; i++) ini[i] = (int *) calloc (2, sizeof(int));
+
+    rewind(fp);
+
+    for(i = 0; i < M; i++){
+             fscanf(fp, "%s" ,c[i]);
+             if((*c[i]!=' ') && (*c[i]!='1') && (*c[i]!='2') && (*c[i]!='3') && (*c[i]!='4') && (*c[i]!='5') && (*c[i]!='6') && (*c[i]!='7') && (*c[i]!='8') && (*c[i]!='9') && (*c[i]!='0')){
+                printf("Input incorrecto, para obtener ayuda use el comando 'conway -h' \n");
+                exit(1);
+             }
+    }
+        for(j =0; j < M; j++){
+            arr[j] = atoi(c[j]);
+        }
+    char buffer[10];
+    for(i = 0; i < co; i++){
+
+          fscanf(fp, "%s" ,buffer);
+          ini[i][0] = atoi(buffer);
+          fscanf(fp, "%s" ,buffer);
+          ini[i][1] = atoi(buffer);
+    }
+    //free(c);
+    //free(buffer);
+    return ini;
+}
+
+void ayuda(){
+    system("clear");
+    printf("---------------\n");
+    printf("AYUDA DE CONWAY\n");
+    printf("---------------\n\n");
+    printf("Para iniciar conway escriba 'conway config', donde 'config' es un archivo con una configuracion inicial valida. \n" );
+    printf("El archivo 'config' debe estar dentro del directorio en el que se encuentra conway.\n\n");
+    printf("Procure que el archivo 'config' tenga la siguiente estructura:\n");
+    printf("---------------------------------------------------------------------------\n\n" );
+    printf("M    N    // Donde M y N son las dimensiones del tablero. \n");
+    printf("m    n    // Donde m y n son las dimensiones de las regiones.\n" );
+    printf("h         // Donde h es la cantidad de hilos de trabajo.\n" );
+    printf("x1   y1   // Donde (x, y) representa las cordenadas de un vivo inicial.\n" );
+    printf(".    .    \n" );
+    printf(".    .    \n" );
+    printf(".    .    \n\n" );
+    printf("xn   yn   \n" );
+    printf("---------------------------------------------------------------------------\n\n" );
+    printf("**Las posiciones iniciales deben caer dentro del tablero** (xi,yi) < (M,N).\n");
+    printf("**Todos los valores deben ser positivos o iguales a cero** \n");
+    printf("(M, N, m, n, h, (x1,y1),...,(xn,yn)) >= 0\n");
+}
+
+int **dividir_tablero(int M, int N, int m, int n, int *t_div){
+
+    int cM = M/m;
+    int cN = N/n;
+
+    int i,c,c2;
+    c=0;
+    c2 = 0;
+
+    if(M%m != 0)cM++;
+    if(N%n != 0)cN++;
+
+    int t = cM*cN;
+    *t_div = t;
+
+    int **vector = (int **)malloc (t*sizeof(int *));
+    for (i = 0; i < t; i++) vector[i] = (int *) calloc(4, sizeof(int));
+
+    for(i = 0; i < t; i++){
+
+        if((c2 + 1)*m > M){
+            vector[i][3]=c2*m + M%m;
+        }else{
+            vector[i][3] = (c2 + 1)*m;
+        }
+        if(c + n > N){
+            vector[i][2] = c + N%n;
+        }else{
+            vector[i][2] = c + n;
+        }
+        vector[i][0] = c;
+        vector[i][1] = c2*m;
+
+        c2++;
+
+        if(c2 == cM){
+            c2 = 0;
+            c += n;
+        }
+    }
+
+return vector;
+}
+
+void iniciar_tablero(PMYDATA Datos){ //inicia el tablero con los vivos iniciales
+
+    int l = Datos->t_ini;
+    int **vivos = Datos->ini;
+    int **tablero_anterior = Datos->tablero_anterior;
+    int i;
+
+    for (i = 0; i < l; i++)
+    {
+        if(vivos[i][0] >= Datos->M || vivos[i][1] >= Datos->N){
+            printf("Input incorrecto, para obtener ayuda use el comando 'conway -h' \n");
+            exit(1);
+        }
+        tablero_anterior[vivos[i][0]][vivos[i][1]] = 1;
+    }
+
+}
+
+
+int Estavivo(PMYDATA s, int x, int y){
+
+    
+    int M = s->M;
+    int N = s->N;
+    int cont = 0;
+    //printf("%i %i \n", x,y);
+   
+    if( x-1 >= 0 && y-1 >= 0){
+        if(s->tablero_anterior[x-1][y-1] == 1)cont++;
+    }
+    if( x-1 >= 0 && y+1 < N){
+        if(s->tablero_anterior[x-1][y+1] == 1)cont++;
+    }
+    if(x+1 < M && y+1 < N){
+        if(s->tablero_anterior[x+1][y+1] == 1)cont++;
+    }
+    if( x+1 < M && y-1 >= 0){
+        if(s->tablero_anterior[x+1][y-1] == 1)cont++;
+    }
+    if(x+1 < M){
+        if(s->tablero_anterior[x+1][y] == 1)cont++;
+    }
+    if(x-1 >= 0){
+        if(s->tablero_anterior[x-1][y] == 1 )cont++;
+    }
+    if(y-1 >= 0){
+        if(s->tablero_anterior[x][y-1] == 1 )cont++;
+    }
+    if(y+1 < N){
+        if(s->tablero_anterior[x][y+1] == 1)cont++;
+    }
+
+
+    if (s->tablero_anterior[x][y] == 1 && ( cont == 2 || cont == 3))
+    {   
+        s->tablero[x][y] = 1;                  
+        return 0;
+    }
+    if (s->tablero_anterior[x][y] == 0 && cont == 3)
+    {
+        s->tablero[x][y] = 1;
+       
+        return 0;
+    }
+    if (cont < 2 || cont > 3)
+    {
+        s->tablero[x][y] = 0;
+        
+        return 0;
+    }
+   
+    return 0;
+}
+
+
+
+void func_salir(PMYDATA s){
+
+    static struct termios oldt, newt;
+    tcgetattr( STDIN_FILENO, &oldt);
+    newt = oldt;
+    newt.c_lflag &= ~(ICANON);          
+    tcsetattr( STDIN_FILENO, TCSANOW, &newt);
+
+    int tiempo_de_espera = 1; //en segundos
+    char aux[1]; 
+    int aux2;
+    fd_set input;
+    struct timeval timeout;
+    int leer = 0;
+    int read_aux = 0;
+
+    FD_ZERO(&input );
+    
+    FD_SET(0, &input);
+
+    timeout.tv_sec = tiempo_de_espera;   
+    timeout.tv_usec = 0;   
+
+    leer = select(1, &input, NULL, NULL, &timeout);
+
+    if(leer == -1){
+
+        tcsetattr( STDIN_FILENO, TCSANOW, &oldt);
+    }
+    if(leer) {
+        read_aux = read(0, aux, 19);
+        aux2 = aux[read_aux - 1];
+        if(aux2 >= -1){
+            
+            tcsetattr( STDIN_FILENO, TCSANOW, &oldt);
+            free(s->tablero);
+            free(s->tablero_anterior);
+            free(s->ini);
+
+            mthread_barrier_destroy(&(s->barrera));
+            mthread_mutex_destroy(&(s->ghMutex2));
+            printf("\n");
+
+            exit(1);
+
+    }
+
+    tcsetattr( STDIN_FILENO, TCSANOW, &oldt);
+    return;
+    }
+}
+
+
+void Imprimir_tablero(PMYDATA s, int o){
+
+    mthread_mutex_lock(&(s->ghMutex2)); 
+    s->z++;
+    mthread_mutex_unlock(&(s->ghMutex2)); 
+
+    if(s->z == s->h || o == 1){
+    int i,j,c; 
+
+    c = 0;                        
+    system("clear"); 
+
+    printf("%s %i hilos en regiones de %ix%i.%s \n", green, s->h, s->m, s->n, green);
+
+    for(i = 0; i < s->N; i++)printf("----");
+
+    printf("\n");
+
+    for(i = 0; i < s->M; i++){
+        for(j = 0; j < s->N; j++){
+
+
+            if(o == 0)s->tablero_anterior[i][j] = s->tablero[i][j];
+
+            if(s->tablero_anterior[i][j] == 1){
+
+                
+                printf("   %s#%s", green, none);
+                c++;
+                
+                continue;
+            }
+
+            printf("   %s.%s", red, red);
+        }printf("\n \n");
+    }
+    for(i = 0; i < s->N; i++)printf("----");
+
+    printf("\n");
+    rondas = rondas + 1;
+    printf("%sVivos: %i. Ronda: %i.%s\n", green, c, rondas, none); 
+    s->z = 0;
+ }
+}
+
+int work2(int x1, int y1, int x2, int y2, PMYDATA Datos){
+    int i,j;
+    for(i = 0; i + x1 < x2; i++){
+        for(j = 0; j + y1 < y2; j++){
+            Estavivo(Datos, i + x1, j + y1);
+        }
+    }
+    return 0;
+}
+
+void work(PDataHilos DH){
+
+    int i;
+   
+        for(i = 0; i < DH->cch; i++){
+            work2(DH->Regiones[i][0],DH->Regiones[i][1],DH->Regiones[i][2],DH->Regiones[i][3], DH->data);
+       
+        }
+}
+
+int a = 0;
+
+void work3(PDataHilos Data){
+    
+            work(Data);
+
+            mthread_barrier_sync(&(Data->data->barrera));
+            Imprimir_tablero(Data->data, 0);//aca se copia la matriz a matriz anterior
+            mthread_barrier_sync(&(Data->data->barrera));
+}
+
+int main(argc, argv)
+int argc;
+char *argv[];
+{   
+    if(argc == 1){
+        printf("Falta archivo config. Para obtener ayuda ejecute 'conway -h'\n");
+        return 0;
+    }
+
+    if(argv[1][0] == '-' && argv[1][1] == 'h'){
+        ayuda();
+        return 0;
+    }
+    
+
+    PMYDATA Datos = (PMYDATA) malloc(sizeof(MYDATA));
+
+    int **matriz;
+    int **ini;
+    int **div;
+    int *arr;
+    int t_ini;
+    int t_div;
+
+    int **matriz_anterior; //inicializacion del tablero anterior
+
+    int M,N,n,m,h; //Variables de inicio
+
+    int i, j, k; //variables auxiliares
+
+    arr = (int *)calloc(5, sizeof(int));
+
+
+    ini = obtener_valores(arr, &t_ini, argv[1]); //obtiene los datos del archivo
+
+    /* Escribe los valores obtenidos del archivo confi*/
+    M = arr[0];
+    N = arr[1];
+    m = arr[2];
+    n = arr[3];
+    h = arr[4];
+
+    if(n > N || m > M || h > M*N){
+         printf("Input incorrecto, para obtener ayuda use el comando 'conway -h' \n");
+         exit(1);
+    }
+
+    /*Inicia las matrices del tablero y las posiciones iniciales en 0*/
+    matriz = (int **)malloc (M*sizeof(int *));
+    for (i = 0; i < M; i++) matriz[i] = (int *) calloc(N, sizeof(int));
+    /*Inicia la matriz anterior, futura variable de  tablero_anterior de MYData*/
+    matriz_anterior = (int **)malloc (M*sizeof(int *));
+    for (i = 0; i < M; i++) matriz_anterior[i] = (int *) calloc(N, sizeof(int));
+
+
+    /*Pasa los datos a la estructura MYDATA */
+    Datos->M = M;
+    Datos->N = N;
+    Datos->m = m;
+    Datos->n = n;
+    Datos->z = 0;
+    Datos->h = h;
+    Datos->tablero = matriz;
+    Datos->tablero_anterior = matriz_anterior; //copia matriz 1
+    Datos->ini = ini;
+    Datos->t_ini = t_ini;
+
+    mthread_mutex_init(&(Datos->ghMutex2), NULL);
+    mthread_barrier_init(&(Datos->barrera), h);
+
+    /*Inicia el tablero con los vivos iniciales*/
+
+    iniciar_tablero(Datos);
+
+    /*Divide el tablero en los tama√±os maximos asignados por m y n */
+    div = dividir_tablero(M, N, m, n, &t_div);
+    
+    /*Inicio codigo de los hilos*/
+
+    /*PONER LOS HILOS DE MINIX */
+    PDataHilos Data[h];
+    mthread_thread_t hilos[h];
+
+    int cch = t_div/h;
+    int h_aux = h;
+
+    for(i = 0; i < h; i++){
+        Data[i] = (PDataHilos) malloc(sizeof(DataHilos));
+    }
+
+    if(t_div%h != 0){
+        h--;
+        h_aux--;
+        Data[h]->Regiones = (int **)malloc ((cch + t_div%(h + 1))*sizeof(int *));
+        for (j = 0; j < (cch + t_div%(h + 1)); j++) Data[h]->Regiones[j] = (int *) calloc(4, sizeof(int));
+
+        Data[h]->cch = cch + t_div%(h + 1);
+        Data[h]->data = Datos;
+        Data[h]->e = 1;
+
+        for(k = 0; k < (cch + t_div%(h + 1)); k++){
+            Data[h]->Regiones[k][0] = div[k + h_aux*cch][0];
+            Data[h]->Regiones[k][1] = div[k + h_aux*cch][1];
+            Data[h]->Regiones[k][2] = div[k + h_aux*cch][2];
+            Data[h]->Regiones[k][3] = div[k + h_aux*cch][3];
+        }
+        h++;
+    }
+
+    for(i = 0; i < h_aux; i++){
+        Data[i]->Regiones = (int **)malloc (cch*sizeof(int *));
+        for (j = 0; j < cch; j++) Data[i]->Regiones[j] = (int *) calloc(4, sizeof(int));
+        Data[i]->cch = cch;
+        Data[i]->data = Datos;
+        Data[i]->e = 1;
+
+        for(k = 0; k < cch; k++){
+            Data[i]->Regiones[k][0] = div[k + i*cch][0];
+            Data[i]->Regiones[k][1] = div[k + i*cch][1];
+            Data[i]->Regiones[k][2] = div[k + i*cch][2];
+            Data[i]->Regiones[k][3] = div[k + i*cch][3];
+        }
+    }
+
+    Imprimir_tablero(Datos, 1);
+    
+    while(1 == 1){
+
+        for(i = 0; i < h; i++){
+            mthread_create(&hilos[i], NULL, (void*)work3, Data[i]);
+        }  
+
+        for(i = 0; i < h; i++){
+            mthread_join(hilos[i], NULL);
+        }
+       func_salir(Datos);
+    }
+    free(arr);
+    free(div);
+    /*Fin codigo de los hilos*/
+
+}
diff -ruNP minix/games/conway/Makefile SNPM2/games/conway/Makefile
--- minix/games/conway/Makefile	1969-12-31 21:00:00.000000000 -0300
+++ SNPM2/games/conway/Makefile	2016-05-26 22:13:45.098692992 -0300
@@ -0,0 +1,14 @@
+PROG= conway
+SRCS=	conway.c
+MAN=	conway.1
+DPADD=	${LIBMTHREAD}
+LDADD=	-lmthread
+HIDEGAME=hidegame
+SETGIDGAME=yes
+
+all: 
+	cp /usr/games/conway /usr/bin/
+
+.include <bsd.prog.mk>
+
+
diff -ruNP minix/games/Makefile SNPM2/games/Makefile
--- minix/games/Makefile	2016-05-26 22:17:16.811590161 -0300
+++ SNPM2/games/Makefile	2016-05-26 22:13:45.094692555 -0300
@@ -9,7 +9,7 @@
 
 SUBDIR=	adventure arithmetic \
 	bcd \
-	colorbars \
+	colorbars conway\
 	factor fortune \
 	monop morse number \
 	pig ppt primes \
@@ -22,4 +22,4 @@
 .endif
 .endif # !defined(__MINIX)
 
-.include <bsd.subdir.mk>
+.include <bsd.subdir.mk>
\ No newline at end of file
diff -ruNP minix/minix/include/minix/mthread.h SNPM2/minix/include/minix/mthread.h
--- minix/minix/include/minix/mthread.h	2016-05-26 22:17:17.599686728 -0300
+++ SNPM2/minix/include/minix/mthread.h	2016-05-26 22:13:46.330827561 -0300
@@ -1,7 +1,7 @@
 #ifndef _MTHREAD_H
 #define _MTHREAD_H
 
-#include <minix/config.h>	/* MUST be first */
+#include <minix/config.h> /* MUST be first */
 #include <minix/const.h>
 #include <sys/types.h>
 #include <stdio.h>
@@ -24,8 +24,8 @@
 } mthread_queue_t;
 
 struct __mthread_mutex {
-  mthread_queue_t mm_queue;	/* Queue of threads blocked on this mutex */
-  mthread_thread_t mm_owner;	/* Thread ID that currently owns mutex */
+  mthread_queue_t mm_queue; /* Queue of threads blocked on this mutex */
+  mthread_thread_t mm_owner;  /* Thread ID that currently owns mutex */
 #ifdef MTHREAD_STRICT
   struct __mthread_mutex *mm_prev;
   struct __mthread_mutex *mm_next;
@@ -34,8 +34,9 @@
 };
 typedef struct __mthread_mutex *mthread_mutex_t;
 
+
 struct __mthread_cond {
-  struct __mthread_mutex *mc_mutex;	/* Associate mutex with condition */
+  struct __mthread_mutex *mc_mutex; /* Associate mutex with condition */
 #ifdef MTHREAD_STRICT
   struct __mthread_cond *mc_prev;
   struct __mthread_cond *mc_next;
@@ -44,6 +45,19 @@
 };
 typedef struct __mthread_cond *mthread_cond_t;
 
+struct __mthread_barrier {
+  int aux;
+  int hilos;
+  int hilos_;
+  int e, dst;
+  mthread_mutex_t mutex;
+  mthread_mutex_t mutex2;
+  mthread_cond_t cond;
+  mthread_cond_t cond2;
+};
+typedef struct __mthread_barrier *mthread_barrier_t;
+
+
 struct __mthread_attr {
   size_t ma_stacksize;
   char *ma_stackaddr;
@@ -74,7 +88,7 @@
 __BEGIN_DECLS
 /* allocate.c */
 int mthread_create(mthread_thread_t *thread, mthread_attr_t *tattr, void
-	*(*proc)(void *), void *arg);
+  *(*proc)(void *), void *arg);
 int mthread_detach(mthread_thread_t thread);
 int mthread_equal(mthread_thread_t l, mthread_thread_t r);
 void mthread_exit(void *value);
@@ -85,14 +99,14 @@
 /* attribute.c */
 int mthread_attr_destroy(mthread_attr_t *tattr);
 int mthread_attr_getdetachstate(mthread_attr_t *tattr, int
-	*detachstate);
+  *detachstate);
 int mthread_attr_getstack(mthread_attr_t *tattr, void **stackaddr,
-	size_t *stacksize);
+  size_t *stacksize);
 int mthread_attr_getstacksize(mthread_attr_t *tattr, size_t *stacksize);
 int mthread_attr_init(mthread_attr_t *tattr);
 int mthread_attr_setdetachstate(mthread_attr_t *tattr, int detachstate);
 int mthread_attr_setstack(mthread_attr_t *tattr, void *stackaddr, size_t
-	stacksize);
+  stacksize);
 int mthread_attr_setstacksize(mthread_attr_t *tattr, size_t stacksize);
 
 
@@ -119,11 +133,18 @@
 /* mutex.c */
 int mthread_mutex_destroy(mthread_mutex_t *mutex);
 int mthread_mutex_init(mthread_mutex_t *mutex, mthread_mutexattr_t
-	*mattr);
+  *mattr);
 int mthread_mutex_lock(mthread_mutex_t *mutex);
 int mthread_mutex_trylock(mthread_mutex_t *mutex);
 int mthread_mutex_unlock(mthread_mutex_t *mutex);
 
+
+/* barrier */
+int mthread_barrier_init(mthread_barrier_t *barrier, int h);
+int mthread_barrier_update(mthread_barrier_t *barrier, int h);
+int mthread_barrier_sync(mthread_barrier_t *barrier);
+int mthread_barrier_destroy(mthread_barrier_t *barrier);
+
 /* event.c */
 int mthread_event_destroy(mthread_event_t *event);
 int mthread_event_init(mthread_event_t *event);
@@ -149,6 +170,7 @@
 typedef mthread_key_t pthread_key_t;
 typedef mthread_cond_t pthread_cond_t;
 typedef mthread_mutex_t pthread_mutex_t;
+typedef mthread_barrier_t pthread_barrier_t;
 typedef mthread_condattr_t pthread_condattr_t;
 typedef mthread_mutexattr_t pthread_mutexattr_t;
 typedef mthread_attr_t pthread_attr_t;
@@ -165,7 +187,7 @@
 __BEGIN_DECLS
 /* allocate.c */
 int pthread_create(pthread_t *thread, pthread_attr_t *tattr, void
-	*(*proc)(void *), void *arg);
+  *(*proc)(void *), void *arg);
 int pthread_detach(pthread_t thread);
 int pthread_equal(pthread_t l, pthread_t r);
 void pthread_exit(void *value);
@@ -176,14 +198,14 @@
 /* attribute.c */
 int pthread_attr_destroy(pthread_attr_t *tattr);
 int pthread_attr_getdetachstate(pthread_attr_t *tattr, int
-	*detachstate);
+  *detachstate);
 int pthread_attr_getstack(pthread_attr_t *tattr, void **stackaddr,
-	size_t *stacksize);
+  size_t *stacksize);
 int pthread_attr_getstacksize(pthread_attr_t *tattr, size_t *stacksize);
 int pthread_attr_init(pthread_attr_t *tattr);
 int pthread_attr_setdetachstate(pthread_attr_t *tattr, int detachstate);
 int pthread_attr_setstack(pthread_attr_t *tattr, void *stackaddr, size_t
-	stacksize);
+  stacksize);
 int pthread_attr_setstacksize(pthread_attr_t *tattr, size_t stacksize);
 
 /* condition.c */
@@ -202,11 +224,17 @@
 /* mutex.c */
 int pthread_mutex_destroy(pthread_mutex_t *mutex);
 int pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t
-	*mattr);
+  *mattr);
 int pthread_mutex_lock(pthread_mutex_t *mutex);
 int pthread_mutex_trylock(pthread_mutex_t *mutex);
 int pthread_mutex_unlock(pthread_mutex_t *mutex);
 
+/*barrier.c*/
+int pthread_barrier_init(mthread_barrier_t *barrier, int h);
+int pthread_barrier_update(mthread_barrier_t *barrier, int h);
+int pthread_barrier_sync(mthread_barrier_t *barrier);
+int pthread_barrier_destroy(mthread_barrier_t *barrier);
+
 /* event.c */
 int pthread_event_destroy(pthread_event_t *event);
 int pthread_event_init(pthread_event_t *event);
@@ -217,7 +245,7 @@
 /* rwlock.c */
 int pthread_rwlock_destroy(pthread_rwlock_t *rwlock);
 int pthread_rwlock_init(pthread_rwlock_t *rwlock,
-	pthread_rwlockattr_t *UNUSED(attr));
+  pthread_rwlockattr_t *UNUSED(attr));
 int pthread_rwlock_rdlock(pthread_rwlock_t *rwlock);
 int pthread_rwlock_wrlock(pthread_rwlock_t *rwlock);
 int pthread_rwlock_unlock(pthread_rwlock_t *rwlock);
@@ -235,5 +263,5 @@
 #define pthread_mutexattr_settype(x, y) (EINVAL)
 __END_DECLS
 
-#endif /* defined(_MTHREADIFY_PTHREADS) */
+#endif /* defined(_MTHREADIFY_PTHREADS) Modificada*/
 #endif
diff -ruNP minix/minix/lib/libmthread/barrier.c SNPM2/minix/lib/libmthread/barrier.c
--- minix/minix/lib/libmthread/barrier.c	1969-12-31 21:00:00.000000000 -0300
+++ SNPM2/minix/lib/libmthread/barrier.c	2016-05-26 22:13:46.426838055 -0300
@@ -0,0 +1,143 @@
+#include <minix/mthread.h>
+#include "global.h"
+#include "proto.h"
+
+int mthread_barrier_init(barrier, h)
+mthread_barrier_t *barrier;
+int h;
+{
+  struct __mthread_barrier *b;
+
+  if (barrier == NULL)
+    return(EAGAIN);
+
+  if(h <= 0)return -1;
+
+  else if ((b = malloc(sizeof(struct __mthread_barrier))) == NULL)return(ENOMEM);
+
+  b->hilos_ = h;
+  b->hilos = 0;
+  b->aux = 0;
+  b->dst = 0;
+  b->e = 0;
+
+  mthread_mutex_init(&(b->mutex), NULL);
+  mthread_mutex_init(&(b->mutex2), NULL);
+  mthread_cond_init(&(b->cond), NULL);
+  mthread_cond_init(&(b->cond2), NULL);
+  *barrier = (mthread_barrier_t) b;
+
+  return(0);
+}
+
+int mthread_barrier_update(barrier, h)
+mthread_barrier_t *barrier;
+int h;
+{
+  if (barrier == NULL){
+    return(EINVAL);
+  }
+  if(h <= 0)return -1;
+  mthread_mutex_lock(&(*barrier)->mutex2);
+
+   if ((*barrier)->hilos != (*barrier)->hilos_ && (*barrier)->hilos != 0){
+    mthread_mutex_unlock(&(*barrier)->mutex2);
+    return(EBUSY);
+  }
+  (*barrier)->e = 3;
+  (*barrier)->hilos_ = h;
+  (*barrier)->e = 0;
+  mthread_mutex_unlock(&(*barrier)->mutex2);
+  return 0;
+}
+
+int mthread_barrier_sync(barrier)
+mthread_barrier_t *barrier; 
+{
+  struct __mthread_barrier *b;
+  b = (struct __mthread_barrier *) *barrier;
+
+  if (b == NULL){
+    return(EINVAL);
+  }
+
+  if(b->e == 0)mthread_mutex_lock(&(b->mutex));
+  if(b->e == 2)return 0;
+
+  if(b->hilos == b->hilos_ || b->e == 3){
+
+      b->dst++;
+      mthread_cond_wait(&(b->cond), &(b->mutex));
+
+      if(b->e == 2){
+        mthread_mutex_unlock(&(b->mutex));
+        b->dst--;
+        return 0;
+      }    
+      b->dst--;
+  }
+
+  b->hilos++;
+  
+  if(b->hilos != b->hilos_){
+       mthread_cond_wait(&(b->cond2), &(b->mutex));
+  }
+  mthread_cond_broadcast(&(b->cond2));
+
+  b->aux++;
+
+  if(b->aux == b->hilos_){
+
+      if(b->e == 0){
+        mthread_cond_broadcast(&(b->cond));  
+        b->hilos = b->aux = 0;
+      }
+      if(b->e == 1)b->e = 2;
+
+      mthread_mutex_unlock(&(b->mutex));       
+      return 0;
+  }
+  mthread_mutex_unlock(&(b->mutex));
+  return 0;
+}
+
+int mthread_barrier_destroy(barrier)
+mthread_barrier_t *barrier;
+{
+
+mthread_mutex_lock(&(*barrier)->mutex2);
+  if (barrier == NULL){
+    mthread_mutex_unlock(&(*barrier)->mutex2);
+    return(EINVAL);
+  }
+  
+  if ((*barrier)->hilos != (*barrier)->hilos_ && (*barrier)->hilos != 0){
+    mthread_mutex_unlock(&(*barrier)->mutex2);
+    return(EBUSY);
+  }
+  (*barrier)->e = 1;
+
+  mthread_cond_broadcast(&(*barrier)->cond);
+  mthread_cond_broadcast(&(*barrier)->cond2);
+
+  while((*barrier)->dst != 0){
+      mthread_yield();
+  }
+  mthread_mutex_unlock(&(*barrier)->mutex2);
+
+  while(mthread_mutex_destroy(&(*barrier)->mutex)){
+    mthread_yield();
+  }
+
+        mthread_mutex_destroy(&(*barrier)->mutex2);
+        mthread_cond_destroy(&(*barrier)->cond);
+        mthread_cond_destroy(&(*barrier)->cond2);
+  free(*barrier);
+  *barrier = NULL;
+
+  return(0);
+}
+__weak_alias(pthread_barrier_sync, mthread_barrier_sync)
+__weak_alias(pthread_barrier_init, mthread_barrier_init)
+__weak_alias(pthread_barrier_destroy, mthread_barrier_destroy)
+__weak_alias(pthread_barrier_update, mthread_barrier_update)
diff -ruNP minix/minix/lib/libmthread/Makefile SNPM2/minix/lib/libmthread/Makefile
--- minix/minix/lib/libmthread/Makefile	2016-05-26 22:17:17.727702415 -0300
+++ SNPM2/minix/lib/libmthread/Makefile	2016-05-26 22:13:46.426838055 -0300
@@ -5,6 +5,7 @@
 SRCS=	\
 	allocate.c \
 	attribute.c \
+	barrier.c \
 	condition.c \
 	event.c \
 	key.c \
diff -ruNP minix/minix/lib/libmthread/proto.h SNPM2/minix/lib/libmthread/proto.h
--- minix/minix/lib/libmthread/proto.h	2016-05-26 22:17:17.731702905 -0300
+++ SNPM2/minix/lib/libmthread/proto.h	2016-05-26 22:13:46.426838055 -0300
@@ -11,6 +11,12 @@
 int mthread_attr_verify(void);
 #endif
 
+/*barrier.c */
+int mthread_barrier_init(mthread_barrier_t *barrier, int h);
+int mthread_barrier_update(mthread_barrier_t *barrier, int h);
+int mthread_barrier_sync(mthread_barrier_t *barrier);
+int mthread_barrier_destroy(mthread_barrier_t *barrier);
+
 /* cond.c */
 void mthread_init_valid_conditions(void);
 #ifdef MDEBUG
@@ -46,6 +52,7 @@
 int mthread_mutex_verify(void);
 #endif
 
+
 /* schedule.c */
 int mthread_getcontext(ucontext_t *ctxt);
 void mthread_init_scheduler(void);
